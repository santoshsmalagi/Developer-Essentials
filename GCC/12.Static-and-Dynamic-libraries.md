# 12. Static and Dynamic libraries

## Linking with external libraries

Refer Section 2.6

## Link order of libraries

Refer Section 2.7

## Library header files

## Examining object files and binaries

The following table summarizes several useful tools for working with and examining the contents of object files and binaries:

| Utilities                              | Purpose                                                                                |
|----------------------------------------|----------------------------------------------------------------------------------------|
| ``strace`` (Linux command line utility)    | print a list of low-level (kernel) system calls made when the  binary is executed      |
| ``ltrace`` (Linux command line utility)    | print a list of calls made to the library functions when the binary is executed        |
| ``file``  (Linux command line utility)     | to find the most basic details about the generated binary                              |
| ``size`` (part of GNU Binutils)            | list the sizes of various sections (i.e. text, data, bss) within a binary              |
| ``nm`` (part of GNU Binutils)              | primarily to examine the symbol table and check whether a function/variable is defined |
| ``ldd`` (Linux utility, actually a script) | examine the shared lib dependencies                                                    |
| ``objdump`` (part of GNU Binutils)         | display information about object files                                                 |
| ``readelf`` (part of GNU Binutils)         | display information about an ELF file                                                  |
| ``strip`` (part of GNU Binutils)           | discards symbols               |
| ``addr2line`` (Linux command line utility)   | trace the line number in src code using a debug build                                  |
| ``gdb`` (Linux utility)                                    | The classic C/C++ source level debugger on Linux systems                               |

#### ``file``
The ``file`` command is very handy as it reveals some very basic information about about an object file or binary.
* whether the binary was compiled with dynamic or static linking
* the architecture it was compiled for, e.g. x86-64
* it's internal representation (ELF or COFF) and version (i.e. ``version 1(SYSV)``)
* the word size - 32 bit or 64 bits
* it's *endianness* - little-endian (LSB byte first) or big-endian (MSB byte first)
* whether the symbols are present or stripped.

#### ``strace``
#### ``ltrace``
#### ``file``
#### ``size``
#### ``nm``
#### ``ldd``
#### ``objdump``
#### ``readelf``
#### ``strip``
#### ``addr2line``
#### ``gdb``

The usage of these utilities will be illustrated using the classic *Hello-World!* program written using multiple source files as follows: 

#### Compile and generate object files and binary

```helloWorld.h``` declares the function prototype for ```hello```.

```C
/**********************************************
helloWorld.h
***********************************************/

#ifndef HELLO_WORLD
#define HELLO_WORLD

void hello(const char *str);

#endif
```

```helloWorld.c``` defines the function ```hello```, which simply prints a string to the ```STDOUT```.

```C
/**********************************************
helloWorld.c
***********************************************/

#include <stdio.h>
#include "helloWorld.h"

void hello(const char *str)
{
    printf("%s",str);
}

```

```main.c``` includes ```helloWorld.h``` and calls the function ```hello```.

```C
/**********************************************
main.c
***********************************************/

#include "helloWorld.h"

int main(int argc, char *argv[])
{
    hello("Hello World\n");
    return 0;
}
```

Generate object files (i.e. compile but do not link)

```$ gcc -Wall -c main.c helloWorld.c```

Generate the binary by linking the object files:

```$ gcc -Wall main.o helloWorld.o -o helloWorld```

#### Run the ``file`` command to inspect the object files and the binary

Now if we run the ``file`` command on the two object files and the binary file generated we might get something as follows:

```Shell
malagi@santoshsmalagi:~/CPrograms$ file helloWorld.o
helloWorld.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

malagi@santoshsmalagi:~/CPrograms$ file main.o
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

malagi@santoshsmalagi:~/CPrograms$ file helloWorld
helloWorld: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=afbf91dbb48bcfe69e6a4c77c66e0889f09729ce, for GNU/Linux 3.2.0, not stripped
```

#### Run ``strace`` to find out more about runtime calls to the kernel functions (i.e. low-level system calls)
```Shell
malagi@santoshsmalagi:~/CPrograms$ strace ./helloWorld 
execve("./helloWorld", ["./helloWorld"], 0x7fff0f164a00 /* 49 vars */) = 0
brk(NULL)                               = 0x5612cf4e6000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffc30b76c20) = -1 EINVAL (Invalid argument)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=73633, ...}) = 0
mmap(NULL, 73633, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8b6a243000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\360q\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029224, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8b6a241000
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\t\233\222%\274\260\320\31\331\326\10\204\276X>\263"..., 68, 880) = 68
mmap(NULL, 2036952, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f8b6a04f000
mprotect(0x7f8b6a074000, 1847296, PROT_NONE) = 0
mmap(0x7f8b6a074000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7f8b6a074000
mmap(0x7f8b6a1ec000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19d000) = 0x7f8b6a1ec000
mmap(0x7f8b6a237000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f8b6a237000
mmap(0x7f8b6a23d000, 13528, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f8b6a23d000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f8b6a242540) = 0
mprotect(0x7f8b6a237000, 12288, PROT_READ) = 0
mprotect(0x5612ce29d000, 4096, PROT_READ) = 0
mprotect(0x7f8b6a282000, 4096, PROT_READ) = 0
munmap(0x7f8b6a243000, 73633)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
brk(NULL)                               = 0x5612cf4e6000
brk(0x5612cf507000)                     = 0x5612cf507000
write(1, "Hello World!\n", 13Hello World!
)          = 13
exit_group(0)                           = ?
+++ exited with 0 +++
```

#### Run ``ltrace`` to find out about runtime calls to the library functions


