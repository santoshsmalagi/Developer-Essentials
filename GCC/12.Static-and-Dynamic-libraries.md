# 12. Static and Dynamic libraries

## Linking with external libraries

Refer Section 2.6

## Link order of libraries

Refer Section 2.7

## Library header files

## Examining object files and binaries

The following table summarizes several useful tools for working with and examining the contents of object files and binaries:

| Utilities                              | Purpose                                                                                |
|----------------------------------------|----------------------------------------------------------------------------------------|
| ``strace`` (Linux command line utility)    | print a list of low-level (kernel) system calls made when the  binary is executed      |
| ``ltrace`` (Linux command line utility)    | print a list of calls made to the library functions when the binary is executed        |
| ``file``  (Linux command line utility)     | to find the most basic details about the generated binary                              |
| ``size`` (part of GNU Binutils)            | list the sizes of various sections (i.e. text, data, bss) within a binary              |
| ``nm`` (part of GNU Binutils)              | primarily to examine the symbol table and check whether a function/variable is defined |
| ``ldd`` (Linux utility, actually a script) | examine the shared lib dependencies                                                    |
| ``objdump`` (part of GNU Binutils)         | display information about object files                                                 |
| ``readelf`` (part of GNU Binutils)         | display information about an ELF file                                                  |
| ``strip`` (part of GNU Binutils)           | discards symbols               |
| ``addr2line`` (Linux command line utility)   | trace the line number in src code using a debug build                                  |
| ``gdb`` (Linux utility)                                    | The classic C/C++ source level debugger on Linux systems                               |

Consider the classic *Hello-World!* program written using multiple source files just for illustration purposes. 

```helloWorld.h``` declares the function prototype for ```hello```.

```C
/**********************************************
helloWorld.h
***********************************************/

#ifndef HELLO_WORLD
#define HELLO_WORLD

void hello(cont char *str);

#endif
```

```helloWorld.c``` defines the function ```hello```, which simply prints a string to the ```STDOUT```.

```C
/**********************************************
helloWorld.c
***********************************************/

#include <stdio.h>
#include "helloWorld.h"

void hello(const char *str)
{
    printf("%s",str);
}

```

```main.c``` includes ```helloWorld.h``` and calls the function ```hello```. Since ``main()`` does not directly call the ``printf()`` function there is no need to include the C standard library header ```<stdio.h>```.

```C
/**********************************************
main.c
***********************************************/

#include "helloWorld.h"

int main(int argc, char *argv[])
{
    hello("Hello World\n");
    return 0;
}
```

Generate object files:

```$ gcc -Wall main.c helloWorld.c```

Generate binary by linking the executables:

```$ gcc -Wall main.c helloWorld.c```

#### ``strace``
#### ``ltrace``

#### ``file``
The ``file`` command is very handy as it reveals some very basic information about about an object file or binary. For example it tells us whether the binary was compiled with dynamic or static linking, the architecture it was compiled for, it's internal representation (ELF or COFF), the word size and finally it's *endianness* - little-endian (LSB byte first) or big-endian (MSB byte first).




#### ``size``
#### ``nm``
#### ``ldd``
#### ``objdump``
#### ``readelf``
#### ``strip``
#### ``addr2line``
#### ``gdb``
