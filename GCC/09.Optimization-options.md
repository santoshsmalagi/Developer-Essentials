# 9. Optimization options

GCC is an optimizing compiler. It provides a wide range of options to increase the speed and reduce the size of the executables it generates. Optimization is a complex process - for each high-level command in the source code there are usually many possible combinations of machine instructions that can be used to achieve the final result. The compiler must consider these possibilities and choose the best amongst them.

## Optimization techniques
A few examples of optimization techniques include common sub-expression elimination, function inlining, loop unrolling and scheduling. 

#### Source-level optimizations
The first form of optimization used by GCC occurs at the source-code level and does not require any knowledge of the machine instruction. There are many techniques for source-level optimizations:

* Common subexpression elimination
  * computing an expression in the source code with fewer instructions by reusing already computed results - this rewriting is called common subexpression elimination
  * common subexpression elimination is powerful because it simultaneously increases the speed and reduces the size of the code

* Function inlining
  * increases the efficiency of frequently called functions by avoiding the overhead associated with funciton calls
  * this is achieved by placing the entire function code in place of the function call

#### Speed-space tradeoff
Optimizations with a speed-space tradeoff can also be used to make an executable smaller, at the expense of making it run slower.

* Loop unrolling
    * This form of optimization increases the speed of loops by eliminating the “end of loop” condition on each iteration
    * Since each assignment is independent, it also allows the compiler to use parallelism on processors that support it
    * Loop unrolling is an optimization that increases the speed of the resulting executable but also generally increases its size


#### Scheduling
The lowest level of optimization is scheduling, in which the compiler determines the best ordering of individual instructions.

* Many CPUs also support pipelining, where multiple instructions execute in parallel on the same CPU.
* When scheduling is enabled, instructions must be arranged so that their results become available to later instructions at the right time, and to allow for maximum parallel execution.
* Scheduling improves the speed of an executable without increasing its size, but requires additional memory and time in the compilation process itself (due to its complexity).

#### Optimization levels
GCC provides several options to control the various sorts of optimizations. 

Without any optimization option, the compiler’s goal is to reduce the cost of compilation
and to make debugging produce the expected results

Turning on optimization flags makes the compiler attempt to improve the performance
and/or code size at the expense of compilation time and possibly the ability to debug the
program.

Most optimizations are completely disabled at ‘-O0’ or if an ‘-O’ level is not set on the
command line, even if individual optimization flags are specified. Similarly, ‘-Og’ suppresses
many optimization passes.

-O
-O1 Optimize. Optimizing compilation takes somewhat more time, and a lot more
memory for a large function.

-O2 Optimize even more. GCC performs nearly all supported optimizations that do
not involve a space-speed tradeoff. As compared to ‘-O’, this option increases
both compilation time and the performance of the generated code

-O3 Optimize yet more. ‘-O3’ turns on all optimizations specified by ‘-O2’ and also
turns on the following optimization flags:

-O0 Reduce compilation time and make debugging produce the expected results.
This is the default.

-Og Optimize debugging experience. ‘-Og’ should be the optimization level of choice
for the standard edit-compile-debug cycle, offering a reasonable level of optimization
while maintaining fast compilation and a good debugging experience

> For a complete list of optimization flags turned on by gcc refer the gcc manual

#### Optimization and compiler warnings
