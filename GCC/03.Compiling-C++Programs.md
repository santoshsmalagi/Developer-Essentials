## 3. Compiling C++ programs using g++

This section describes how to compile C++ programs using the GNU C++ compiler or ```g++```. Programs can be compiled from a single source file or from multiple source files, and may use system libraries and header files. Especially for C++ - this includes the C++ Standard Template Library (STL).

## Compiling a simple C++ Program

Consider the classic "Hello World" program in C++ written to a source file named ``helloWorld.cpp``:

```C++
#include <iostream>

int main(int argc, char *argv[])
{
    std::cout << "Hello World!" << std::endl;
    return 0;
}
```

The simplest form of compilation using `g++` is as follows:

```$ g++ helloWorld.cpp```

This compiles ‘helloWorld.cpp’ to an executable (or binary) file named ``a.out``. To load the binary to the system memory and execute it, run:

```$ ./a.out```

It is also possible to specify a name for the output binary file using the ``-o`` option. This option is usually given as the last argument on the command line. If a file with the same name already exists in the current directory it is overwritten.

```$ g++ helloWorld.cpp -o helloWorld```

To turn on compiler warnings, specify the ``-Wall`` option. Source code which does not produce any warnings is said to compile *cleanly*, as in the above example :)

```$ g++ -Wall helloWorld.cpp -o helloWorld```

In order to debug the binary using a symbolic debugger such as gdb it must be compiled with the ``–g`` flag to save the symbol table.

```$ g++ -Wall –g helloWorld.cpp -o helloWorld```

> *GCC will not produce any WARNINGS unless they are explicitly enabled, though ERRORS will always be reported.*

## Compiling multiple source files

Consider the 'Hello World' example above written using two source files and a header file, to illustrate multi-file compilation.

```helloWorld.h``` declares the function prototype for ```hello```.

```C++
/**********************************************
helloWorld.h
***********************************************/

#ifndef HELLO_WORLD
#define HELLO_WORLD

#include <string>
void hello(string str);

#endif
```

```helloWorld.cpp``` defines the function ```hello```, which simply prints a string to the ```STDOUT```.

```C++
/**********************************************
helloWorld.cpp
***********************************************/

#include <iostream>
#include "helloWorld.h"

void hello(string str)
{
    std::cout << str << std::endl;
}

```

```main.cpp``` includes ```helloWorld.h``` and calls the function ```hello```.

```C++
/**********************************************
main.cpp
***********************************************/

#include "helloWorld.h"

int main(int argc, char *argv[])
{
    hello("Hello World");
    return 0;
}
```

To compile:

```$ g++ -Wall main.cpp helloWorld.cpp -o helloWorld```

> *Header files are NEVER included in the command line specification to gcc. The compiler automatically processes them at appropriate times based on the #include pre-processor directives.```

## Creating object files from source files

If a program is stored in a single file then any change to an individual function requires the whole program to be recompiled to produce a new executable. The recompilation of large source files can be very timeconsuming. When programs are stored in independent source files, only the files which have changed need to be recompiled after the source code has been
modified. In the first stage, a file is compiled without creating an executable. The result is referred to as an object file, and has the extension ``.o`` when using g++. In the second stage, the object files are merged together into an executable by a separate program called the linker.

The command-line option ``-c`` is used to compile a source file to an object file. The following command will compile the source file ``main.cpp`` to an object file:

`` $ g++ -Wall -c main.cpp``

This produces an object file ``main.o`` containing the machine code for the ``main`` function. It contains a reference to the external function ``hello``, but the corresponding memory address is left undefined in the object file at this stage (it will be filled in later during the linking step). The corresponding command for compiling the ``hello`` function in the source file ``helloWorld.cpp`` is:

``$ g++ -Wall -c helloWorld.cpp``

This produces an object file ``helloWorld.o`` in the current directory there is no need to use the option ``-o`` to specify the name of the output file. When compiling with ``-c`` the compiler automatically creates an object file whose name is the same as the sourcefile, with ``.o`` extension.

## Creating executables from source files

The final step in creating an executable file is to link the object files together and fill in the missing addresses of external functions.

```$ g++ main.o helloWorld.o -o hello```

To perform the linking step ``g++`` uses the GNU linker utility - ``ld``. In general, linking is faster than compilation—in a large project with many source files, recompiling only those that have been modified can make a significant saving. This is one of the few occasions where there is no need to use the ```-Wall``` warning option, since the individual source files have already been successfully compiled to object code. Once the source files have been compiled, linking is an unambiguous process which either succeeds or fails (it fails only if there are references which cannot be resolved). The process of recompiling only the modified files in a project can be automated using GNU Make.

## Link order of object files

The traditional behavior of compilers and linkers is to search for external functions from left to right in the object files specified on the command line. This means that the object file which contains the definition of a function should appear after all files which call that function. In this case, the file ``helloWorld.o`` containing the function ``hello`` should be specified after ``main.o`` itself, since ``main`` calls ```hello```:

```$ g++ main.o helloWorld.o -o hello    (correct order)```

Most current compilers and linkers will search all object files, regardless of order, but since not all compilers do this it is best to follow the convention of ordering object files from left to right. With some compilers or linkers the opposite ordering would result in an error, because there is no object file containing ```hello``` after ```main.o```. This is worth keeping in mind if you ever encounter unexpected problem with undefined references, and all the necessary object files appear to be present on the command line.

```$ g++ helloWorld.o main.o -o hello    (incorrect order)```

## Specifying a C++ standard using ``-std`` command option

GCC supports the original ISO C++ standard published in 1998, and the 2011, 2014, 2017 and mostly 2020 revisions. By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. Use of the ‘-std’ options listed below disables these extensions where they they conflict with the C++ standard version selected.

|        C++ Standard       |   Language option   | GNU Extension |
|:-------------------------:|:-------------------:|---------------|
| ISO C++ Standard or C++98 | -ansi or -std=c++98 | -std=gnu++98  |
|           C++03           |      -std=c++03     | -std=gnu++03  |
|           C++11           |      -std=c++11     | -std=gnu++11  |
|           C++14           |      -std=c++14     | -std=gnu++14  |
|           C++17           |      -std=c++17     | -std=gnu++17  |
|           C++20           |      -std=c++20     | -std=gnu++20  |

> *The default, if no C++ language dialect options are given is ‘-std=gnu++17’.*
