# 16. Compilation Process

> *Compilation - process of translating source code from a higher level language to a lower level language.*

Deriving an executable from source code is a multi-step process broadly consisting of the following steps:

1. Code development using a text-editor
2. Pre-processing using the GNU Preporcessor (``cpp``) for macro expansion
3. Compilation proper - to convert source code from C/C++ to assembly
4. Assembling - using the GNU Assembler (``as``) to convert assembly code to object files (machine code)
5. Linking - using the GNU Linker (``ld``) to resolve references and create the final executable

![compilation-process](/assets/compilation.jpg)

> *All steps are executed internally by GCC, so unless there is a specific need there is no need to run each step individually.*

Each of these steps will be illustrated using the following example code:

```helloWorld.h``` declares the function prototype for ```hello```.

```C
/**********************************************
helloWorld.h
***********************************************/

#ifndef HELLO_WORLD
#define HELLO_WORLD

void hello(const char *str);

#endif
```

```helloWorld.c``` defines the function ```hello```, which simply prints a string to the ```STDOUT```.

```C
/**********************************************
helloWorld.c
***********************************************/

#include <stdio.h>
#include "helloWorld.h"

void hello(const char *str)
{
    printf("%s",str);
}

```

```main.c``` includes ```helloWorld.h``` and calls the function ```hello```.

```C
/**********************************************
main.c
***********************************************/

#include "helloWorld.h"

int main(int argc, char *argv[])
{
    hello("Hello World\n");
    return 0;
}
```

## 1. Code Development
The first natural step in any software development project is to *write* code using a text editor or a suitable Integrated Development Environment (IDE) of choice. When using the GNU toolchain usually a build automation system such as GNU make is used. The organization of the code into multiple source files and it's architecture vastly influences the compilation pipeline. Not to mention that good programming practices and secure coding result in a binary which is faster, smaller and secure. 

## 2. Pre-processing
The pre-processor ``cpp`` operates on pre-processor directives and performs the following operations on source code:
* includes the contents of header files specified using ``#include`` directives in source files
* replaces constants and macros defined using ``#define`` with their values - it performs no type checking, replaces text as is
* exclude or include lines of code based on ``#if``, ``#elif``, ``#ifdef`` and ``#ifndef`` statements

The C pre-processor ``(cpp)`` can be invoked as follows:

```Shell
$ cpp helloWorld.c
$ cpp helloWorld.c > helloWorld.i
```

> *The ``cpp`` accepts most gcc options such as ``-I``, ``-DNAME`` etc. For a more comphrehensive list refer ``man cpp``*

The pre-processor can be invoked by passing the ``-E`` flag to ``gcc``, output is written only to the ``STDOUT``:

```Shell
$ gcc -Wall -E main.c helloWorld.c
```

Pre-processed output is usually stored in an ``ASCII`` file with ``.i`` extension. 

```Shell
$ gcc -Wall -E main.c helloWorld.c -o main.i helloWorld.i
```

A more compact pre-processed output can be generated by using the ``-P`` flag:

```Shell
$ gcc -Wall -E -P main.c helloWorld.c -o main.i helloWorld.i
```

## 3. Compilation proper

The next stage of the process is the actual compilation of preprocessed source code to assembly language for a specific target processor or processor family. it consists of several stages. Even before lexical analysis can be performed the preprocessed code is optimized by eliminating comments, white spaces, and extracting tokens from the text, etc.

#### Lexical analysis
Lexical analysis or tokenization converts a sequence of characters in the C/C++ program to a sequence of tokens (strings with an assigned and thus identified meaning) which form the smallest indivisble units of a program.

#### Syntax analysis
Parsing or syntactical analysis ensures the tokens conform to the rules of C/C++ language and organizes them into a chain of tokens.

#### Semantic analysis
Checks whether the statements formed by tokens make any sense at all, e.g. the result of adding two integers is an integer etc. 

#### Converting from C/C++ to assembly language
After the source code has been confirmed to have no syntax or semantic errors, the C/C++ constructs are converted to the instruction set of the target CPU. The commandline option ``-S`` instructs ``gcc`` to convert the preprocessed C source code to assembly language without creating an object file:

```Shell
$ gcc -Wall -S hello.i
```

The resulting assembly language source file is stored as ``hello.s`` unless a file name is specifed explicitly. The generated assembly file is specific to the target CPU architecture and contains instructions in that language.

## 4. Assembly
The purpose of the assembler is to convert assembly language into machine code and generate an object file. When there are calls to external functions in the assembly source file, the assembler leaves the addresses of the external functions undefined, to be filled in later by the linker. The instruction mnemonics in the assembly language file are converted to binary opcodes, the object file is not human readable.

```Shell
$ as helloWorld.s -o helloWorld.o
$ as main.s -o main.o
```

Alternatively to perform all steps from pre-processing, compilation upto assembling use the ``-c`` flag:

```Shell
$ gcc -c helloWorld.c -o helloWorld.o
$ gcc -c main.c -o main.o
```

## 5. Linking
The final stage of compilation is the linking of object files to create an executable. The GNU Linker ``(ld)`` resolves references to external functions (defined in libraries, system functions, C/C++ Standard Libraries etc.) and creates the executable.

Instead of invoking the linker explicitly, we can let ``gcc`` handle everything for us:

```Shell
$ gcc -Wall main.o helloWorld.o -o helloWorld
```

https://riptutorial.com/cplusplus/example/26378/the-cplusplus-compilation-process  
https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html  

what happens in each step?  
what are the common sources of error?
