# 6. Static and dynamic analysis options

*Static analysis* examines a program's source code to identify potential problems without actually executing it. GCC's static analysis engine can identify problems such as null pointer deferences, double frees, memory leaks, integer overflow, divide by zero error, out of bounds array access etc.  

*Dynamic or runtime analysis* evaluates and tests a program during its execution. GCC enables code intrumentation during compilation to allow for runtime analysis using one of several *sanitizers* such as *AddressSanitizer (ASan), LeakSanitizer (LSan), ThreadSanitizer (TSan), UndefinedBehaviorSanitizer (UBSsan) and MemorySanitizer (MSan).* The sanitizers are open source tools developed by Google which are integrated into GCC starting version 4.8, since they depend on compiler instrumentation, so one needs to rebuild the program with appropriate flags to enable runtime analysis.

> *Static and dynamic analysis approaches are complementary, because no single approach can find every error. For comphrehensive code quality tests both static and dynamic analysis are performed.*

Use of static/dynamic analysis capabilites increases the compilation/runtime of programs, in most cases this is worth the trade-off.

## Static analysis using GCC

Having a static analysis engine built inside the compiler offers several advantages:

* Static analysis is performed at compile time rather than at run time
* Eliminates the (possible) need for an external or proprietary static analysis tool
* Ensures that the static analysis engine sees *the exact same code* as the compiler thereby avoiding checks on different code bases
* External static analyzers dont see the macro definitions, and hence can sometimes raise false positives

> *Other well known static analysis tools incldue - CppCheck(free), SonarQube(LGPL) and Parasoft C/C++ Test (proprietary)*

To enable GCC's static analysis capabilities use the ```-fanalyzer``` command option. Enabling this option effectively enables the following warnings:
| Warning option                                 | Purpose                                                                                                                                                                                                                                                                                                                                                     |
|------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ``-Wanalyzer-double-fclose``                       | This diagnostic warns for paths through the code in which a FILE * can have fclose called on it more than once                                                                                                                                                                                                                                              |
| ``-Wanalyzer-double-free``                         | This diagnostic warns for paths through the code in which a pointer can have a deallocator called on it more than once, either free, or a deallocator referenced by attribute malloc                                                                                                                                                                        |
| ``-Wanalyzer-exposure-through-output-file``        | This diagnostic warns for paths through the code in which a security-sensitive value is written to an output file (such as writing a password to a log file).                                                                                                                                                                                               |
| ``-Wanalyzer-file-leak``                           | This diagnostic warns for paths through the code in which a <stdio.h> FILE * stream object is leaked                                                                                                                                                                                                                                                        |
| ``-Wanalyzer-free-of-non-heap``                    | This diagnostic warns for paths through the code in which free is called on a non-heap pointer (e.g. an on-stack buffer, or a global).                                                                                                                                                                                                                      |
| ``-Wanalyzer-malloc-leak``                         | This diagnostic warns for paths through the code in which a pointer allocated via an allocator is leaked: either malloc, or a function marked with attribute malloc.                                                                                                                                                                                        |
| ``-Wanalyzer-mismatching-deallocation``            | This diagnostic warns for paths through the code in which the wrong deallocation function is called on a pointer value, based on which function was used to allocate the pointer value. The diagnostic will warn about mismatches between free, scalar delete and vector delete[], and those marked as allocator/ deallocator pairs using attribute malloc. |
| ``-Wanalyzer-possible-null-argument``              | This diagnostic warns for paths through the code in which a possibly-NULL value is passed to a function argument marked with __attribute__ ((nonnull)) as requiring a non-NULL value.                                                                                                                                                                       |
| ``-Wanalyzer-possible-null-dereference``           | This diagnostic warns for paths through the code in which a possibly-NULL value is dereferenced.                                                                                                                                                                                                                                                            |
| ``-Wanalyzer-null-argument``                       | This diagnostic warns for paths through the code in which a value known to be NULL is passed to a function argument marked with __attribute__ ((nonnull)) as requiring a non-NULL value                                                                                                                                                                     |
| ``-Wanalyzer-null-dereference``                    | This diagnostic warns for paths through the code in which a value known to be NULL is dereferenced.                                                                                                                                                                                                                                                         |
| ``-Wanalyzer-shift-count-negative``                | This diagnostic warns for paths through the code in which a shift is attempted with a negative count.                                                                                                                                                                                                                                                       |
| ``-Wanalyzer-shift-count-overflow``                | This diagnostic warns for paths through the code in which a shift is attempted with a count greater than or equal to the precision of the operand’s type                                                                                                                                                                                                    |
| ``-Wanalyzer-stale-setjmp-buffer``                 | This diagnostic warns for paths through the code in which longjmp is called to rewind to a jmp_buf relating to a setjmp call in a function that has returned                                                                                                                                                                                                |
| ``-Wanalyzer-tainted-array-index``                 | This warning requires both ‘-fanalyzer’ and ‘-fanalyzer-checker=taint’ to enable it; use ‘-Wno-analyzer-tainted-array-index’ to disable it.                                                                                                                                                                                                                 |
| ``-Wanalyzer-unsafe-call-within-signal-handler``   | This diagnostic warns for paths through the code in which a function known to be async-signal-unsafe (such as fprintf) is called from a signal handler.                                                                                                                                                                                                     |
| ``-Wanalyzer-use-after-free``                      | This diagnostic warns for paths through the code in which a pointer is used after a deallocator is called on it: either free, or a deallocator referenced by attribute malloc.                                                                                                                                                                              |
| ``-Wanalyzer-use-of-pointer-in-stale-stack-frame`` | This diagnostic warns for paths through the code in which a pointer is dereferenced that points to a variable in a stale stack frame.                                                                                                                                                                                                                       |
| ``-Wanalyzer-write-to-const``                      | This diagnostic warns for paths through the code in which the analyzer detects an attempt to write through a pointer to a const object.                                                                                                                                                                                                                     |
| ``-Wanalyzer-write-to-string-literal``             | This diagnostic warns for paths through the code in which the analyzer detects an attempt to write through a pointer to a string literal                                                                                                                                                                                                                    |

#### Use ``-Wno-<rule>`` to disable a warning
To disable any particular rule use ``-Wno-<rule>`` for example - ``-Wno-analyzer-double-fclose`` disables the check for double close of ``FILE*``.


## Dynamic analysis using GCC

Sanitizers are open source dynamic code analysis tools designed by Google and integrated within GCC:

* AddressSanitizer (ASan)
* LeakSanitizer (LSan)
* ThreadSanitizer (TSan)
* UndefinedBehaviorSanitizer (UBSsan)
* MemorySanitizer (MSan)

Sanitizers depend on compiler instrumentation, so one needs to rebuild the program with appropriate flags to enable runtime analysis with these tools. In general:

```Shell
$ gcc -Wall -g -fsanitize=[sanitizer] [additional flags]
```

Where ``sanitizer`` could be one of:

* ``address`` for AddressSanitizer
* ``leak`` for LeakSanitizer
* ``thread`` for ThreadSanitizer
* ``undefined`` for UndefinedBehaviorSanitizer
* ``memory`` for MemorySanitizer

``[additional_flags]`` could be other compilation flags, such as ``-fno-omit-frame-pointer``, ``fsanitize-recover/fno-sanitize-recover``, ``-fsanitize-blacklist`` etc. It is recommended to use ``-g`` flag to include line numbers and file names in warning messages, which also provides the ability to locate the source of a problem after an application has been run.

## AddressSanitizer (ASan) options

AddressSanitizer (aka ASan) is a memory error detector for C/C++. It detects the following errors:
* Use after free (dangling pointer dereference)
* Heap buffer overflow
* Stack buffer overflow
* Global buffer overflow
* Use after return
* Use after scope
* Initialization order bugs
* Memory leaks 

ASan maintains a map of bits for the memory to determine if the memory location being accessed by a pointer is valid or invalid.

**ASan and gdb**  
It is possible to use ``gdb`` with binaries built using AddressSanitizer in a usual way. When AddressSanitizer finds a bug it calls one of the functions ``__asan_report_{load,store}{1,2,4,8,16}`` which in turn calls ``__asan::ReportGenericError``. If you want gdb to stop before ASan reports an error, set a breakpoint on ``__asan::ReportGenericError``. If you want gdb to stop after ASan has reported an error, set a breakpoint on ``__sanitizer::Die`` or use ``ASAN_OPTIONS=abort_on_error=1``.

Inside gdb you can ask asan to describe a memory location:

``Shell
(gdb) set overload-resolution off
(gdb) p __asan_describe_address(0x7ffff73c3f80)
0x7ffff73c3f80 is located 0 bytes inside of 10-byte region [0x7ffff73c3f80,0x7ffff73c3f8a)
freed by thread T0 here: 
``
