# 6. Static analyzer options

The goal of static analysis is to identify potential problems in a program without actually executing the program. GCC's static analysis engine can identify problems such as null pointer deferences, double frees, memory leaks, integer overflow, divide by zero error, out of bounds array access etc.  

Having a static analysis engine built inside the compiler offers several advantages:

* Static analysis is performed at compile time rather than at run time
* Eliminates the (possible) need for a proprietary static analysis tool
* Ensures that the static analysis engine sees *the exact same code* as the compiler thereby avoiding checks on different code bases

The only caveat to this is that the use of static analysis capabilites increases the compilation time of programs. But often this tradeoff is worth the time!

> *Other well known static analysis tools incldue - CppCheck and SonarQube*

-fanalyzer
This option enables an static analysis of program flow which looks for “interesting”
interprocedural paths through the code, and issues warnings for problems
found on them.
This analysis is much more expensive than other GCC warnings.
Enabling this option effectively enables the following warnings:
-Wanalyzer-double-fclose     --- > This diagnostic warns for paths through the code in which a FILE * can have
fclose called on it more than once.
-Wanalyzer-double-free This diagnostic warns for paths through the code in which a pointer can have a
deallocator called on it more than once, either free, or a deallocator referenced
by attribute malloc.
-Wanalyzer-exposure-through-output-file
-Wanalyzer-file-leak
-Wanalyzer-free-of-non-heap
-Wanalyzer-malloc-leak
-Wanalyzer-mismatching-deallocation
-Wanalyzer-possible-null-argument
-Wanalyzer-possible-null-dereference
-Wanalyzer-null-argument
-Wanalyzer-null-dereference
138 Using the GNU Compiler Collection (GCC)
-Wanalyzer-shift-count-negative
-Wanalyzer-shift-count-overflow
-Wanalyzer-stale-setjmp-buffer
-Wanalyzer-tainted-array-index
-Wanalyzer-unsafe-call-within-signal-handler
-Wanalyzer-use-after-free
-Wanalyzer-use-of-pointer-in-stale-stack-frame
-Wanalyzer-write-to-const
-Wanalyzer-write-to-string-literal
This option is only available if GCC was configured with analyzer support
enabled

** Use -Wno to disable **
-Wno-analyzer-double-fclose
This warning requires ‘-fanalyzer’, which enables it; use
‘-Wno-analyzer-double-fclose’ to disable it.
This diagnostic warns for paths through the code in which a FILE * can have
fclose called on it more than once.
-Wno-analyzer-double-free
This warning requires ‘-fanalyzer’, which enables it; use
‘-Wno-analyzer-double-free’ to disable it.
This diagnostic warns for paths through the code in which a pointer can have a
deallocator called on it more than once, either free, or a deallocator referenced
by attribute malloc.

### Explain most widely used ones

-Wanalyzer-double-fclose     --- > This diagnostic warns for paths through the code in which a FILE * can have
fclose called on it more than once.
-Wanalyzer-double-free This diagnostic warns for paths through the code in which a pointer can have a
deallocator called on it more than once, either free, or a deallocator referenced


https://developers.redhat.com/blog/2020/03/26/static-analysis-in-gcc-10#  
https://embeddedbits.org/bug-hunting-with-static-analysis-tools/   
https://embeddedbits.org/finding-memory-bugs-with-addresssanitizer/  
https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/  
